---
layout: post
title:  "쿠버네티스 기초 - 아키텍처 및 시작"
date:   2019-05-03 11:40:59
author: Hanjoo Cho
categories: Cloud
tags:    Cloud Container K8s
cover:  "/assets/instacode.png"
---
# 쿠버네티스 기초 - 아키텍처 및 시작

## 쿠버네티스의 아키텍처

![k8s_architecture](/assets/image/k8s_architecture.png)

#### kubectl을 통해 받은 명령어를 api server를 통해 kubelet으로 전달하면 Pod( container 묶음 )을 생성하며 서비스를 제공한다. 메타데이터를 저장하는 etcd, 다양한 제어기능을 위한 controller-manager, 자원분배를 도와주는 scheduler, 네트워크 트래픽을 담당하는 kube-proxy도 잇다.

- kubectl : 간단하게 명령어를 보내는 역할

  ex) kubectl get pods ( pod들을 확인하는 명령어 )

- API Server : 명령어를 전달해주는 역할, etcd 클러스터랑 통신 (기본적으로 REST방식으로 통신)

- etcd : 쿠버네티스 클러스터 데이터(포드 수, 상태, 네임 스페이스 등), API 객체 및 서비스 검색 세부정도를 저장하는 데 사용되는 분산 키 값 저장소 ( 메타 데이터가 저장되는 역할 )

- controller - manager : 복제, 서비스계정, 네임스페이스 등을 생성하고 이를 각 노드에 배포하며 관리하는 역할

- scheduler : Pod, 서비스 등 각 자원을 적절한 노드에 할당하는 역할

- kubelet : 노드는 기본적으로 정기적으로 새로운 pod 또는 수정된 pod의 사양으로 포드 및 컨테이너가 원하는 상태로 실행되고 있는지 확인

- kube-porxy : 노드로 들어오는 네트워크 트래픽을 적절한 컨테이너로 라우팅하고, 로드밸런싱 등 노드로 나가는 네트워크 트랙픽을 프록시하고 노드와 마스터간 통신을 관리



## Minikube

쿠버네티스 클러스터는 물리 및 가상 머신 모두에 설치될 수 있다. 쿠버네티스 개발을 시작하려면 Minikube를 사용할 수 있다. 

> Minikube는 로컬 머신에 VM을 만들고 하나의 노드로 구성된 간단한 클러스터를 배포하는 가벼운 쿠버네티스 구현체다. Miinikube는 리눅스, 맥 , 그리고 윈도우 시스템에서 구동이 가능하다. Minikube CLI는 클러스터에 대해 시작,중지,상태 조회 및 삭제 등의 기복적인 부트스트래핑 기능을 제공한다.



## Minikube를 사용해서 클러스터 생성하기

쿠버네티스는 서로 연결되어서 단일 유닛처럼 동작하는 고가용성의 컴퓨터 클러스터를 상호조정한다. 쿠버네티스의 추상화된 개념을 통해 개별 머신에 얽매이지 않고 컨테이너화된 애플리케이션을 클러스터에 배포할 수 있다. **쿠버네티스는 애플리케이션 컨테이너를 클러스터에 분산시키고 스케줄링하는 일을 보다 효율적으로 자동화한다.** 

​	=> 쿠버네티스는 컴퓨터 클러스터에 걸쳐서 애플리케이션 컨테이너의 위치( 스케줄링 )와 실행을 오케스트레이션하는 운영 		 수준의 오픈소스 플랫폼

### 마스터

​	= 클러스터를 상호조정한다.

​	= 클러스터 관리를 담당

> 애플리케이션을 스케줄링하거나, 애플리케이션의 향상성을 유지하거나, 애플리케이션을 스케일링하고, 새로운 변경사항을 순서대로 반영하는 일과 같은 클러스터 내 모든 활동을 조율



### 노드

​	= 애플리케이션을 구동하는 작업자

​	= 쿠버네티스 클러스터 내 워커 머신으로써 동작하는 VM 또는 물리적인 컴퓨터

​	= 각 노드는 노드를 관리하고 쿠버네티스 마스터와 통신하는 kubelet이라는 에이전트를 갖는다.
​		노드는 컨테이너 운영을 담당하는 Docker 또는 rkt와 같은 툴도 갖는다.
​		운영 트래픽을 처리하는 쿠버네티스 클러스터는 최소 세 대의 노드를 가져야 한다.

​	= 각 노드는 파드를 동작시키기 위해 필요한 서비스를 포함하며 마스터 컴포넌트에 의해 관리된다.
​		노드 상의 서비스는 컨테이너 런타임, kubelet 그리고 kube-porxy를 포함한다.

#### 노드 상태

* 주소

  * HostName : 노드의 커널에 의해 알려진 호스트명

    ​					--hostname-override 파라미터를 통해 치환될 수 잇음

  * ExternalIP : 노드의 IP 주소는 외부로 라우팅 가능하다. (클러트서 외부에서 이용가능)

  * InternalIP : 노드의 IP 주소는 클러스터 내에서만 라우트 가능

* 컨디션

~~~
"conditions": [
  {
    "type": "Ready",
    "status": "True"
  }
]
~~~

* 용량

> 노드 상에 사용 가능한 리소스를 나타낸다.
>
> 리소스에는 CPU, 메모리 그리고 노드 상으로 스케줄 되어질 수 있는 최대 파드 수가 있다.

* 정보

> 커널 버전, 쿠버네티스 버전(kubelet, kube-proxy 버전), Docker 버전, OS 이름과 같은 노드에 대한 일반적인 정보이다. 정보는 kubelet애 의해 노드로부터 수집된다.

#### 관리

파드와 서비스와 달리, 노드는 본래 쿠버네티스에 의해 생성되지 않는다. 구글 컴퓨트 엔진과 같은 클라우드 제공사업자에 의해 외부로부터 생성되거나, 물리적 또는 가상 머신의 풀 내에서 존재한다.

그래서 쿠버네티스가 노드를 생성할 때, 노드를 나타내는 오브젝트를 생성한다. 생성 이후, 쿠버네티스는 노드의 유효성 여부를 검사한다.

~~~
{
  "kind": "Node",
  "apiVersion": "v1",
  "metadata": {
    "name": "10.240.79.157",
    "labels": {
      "name": "my-first-k8s-node"
    }
  }
}
~~~

해당 내용으로 노드를 생성하려면, 쿠버네티스는 내부적으로 노드 오브젝트를 생성하고, metadata.name 필드를 근거로 상태 체크를 수행하여 노드의 유효성을 확인한다. 노드가 유효하면, 즉 모든 필요한 서비스가 동작 중이면, 파드를 동작시킬 자격이 된다.

~~~
쿠버네티스는 유효하지 않은 노드로부터 오브젝트를 보호하고 유효한 상태로 이르는지 확인하기 위해 지속적으로 체크한다. 이러한 프로세스를 중지시키기 위해서는 명시적으로 노드 오브젝트를 삭제해야 한다.
~~~

쿠버네티스 노드 인터페이스와 상호작용 하는 3개의 컴포넌트 ( 노드 컨트롤러, kubelet, kubectl )이 존재한다.

* 노드 컨트롤러

노드 컨트롤러는 노드의 다양한 측면을 관리하는 쿠버네티스 마스터 컴포넌트

노드 컨트롤러는 노드가 생성되어 유지되는 동안 다양한 역할을 한다.

* 노드 용량

노드 용량 (cpu 수와 메모리 양)은 노드 오브젝트의 한 부분이다. 일반적으로, 노드는 스스로 등록하고 노드 오브젝트를 생성할 때 자신의 용량을 알린다.

쿠버네티스 스케줄러는 노드 상에 모든 노드에 대해 충분한 리소스가 존재하도록 보장한다.

----



![module_01_cluster](/assets/image/module_01_cluster.svg)

애플리케이션을 쿠버네티스에 배포한다.

​	-> 마스터에 애플리케이션 컨테이너를 구동하라고 지시하는 것

마스터는 컨테이너를 클러스터의 어느 노드에 구동시킬지를 스케줄한다.

노드는 마스터가 제공하는 쿠버네티스 API를 통해서 마스터와 통신한다.

최종 사용자도 쿠버네티스 API를 직접사용해서 클러스터와 상호작용 할 수 있다.



#### Cluster up and running

- minikube 버전확인

~~~
minikube version
~~~

![k8s_version](/assets/image/k8s_version.png)

- minikube 시작

~~~
minikube start
~~~

![k8s_start](/assets/image/k8s_start.png)

- kubectl 버전 확인

~~~
kubectl version
~~~

![k8s_kubectl](/assets/image/k8s_kubectl.png)

- 클러스터 자세히 보기

~~~
kubectl cluster-info
~~~

![k8s_cluster_info](/assets/image/k8s_cluster_info.png)

- 클러스터 안에 있는 노드 보기

~~~
kubectl get nodes
~~~

![k8s_show_node](/assets/image/k8s_show_node.png)

이 명령은 애플리케이션을 호스팅하는 데 사용할 수 있는 모든 노드를 보여준다. 

이제 노드가 하나뿐이며, 상태가 준비됨(배치를 위한 애플리케이션을 수용할 준비가 됨)을 알 수 있다.

---

출처

https://kubernetes.io/ko/docs/tutorials/kubernetes-basics/

https://likefree.tistory.com/19

https://kubernetes.io/ko/docs/concepts/architecture/
