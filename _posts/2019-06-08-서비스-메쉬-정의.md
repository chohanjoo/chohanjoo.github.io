---
layout: post
title:  "서비스 메쉬란 (Service Mesh)"
date:   2019-06-08 15:00:00
tags:    [Service Mash, Container]
comments: true
---
# 서비스 메쉬란 (Service Mesh)



**애플리케이션의 다양한 부분들이 서로 데이터를 공유하는 방식을 제어하는 방법**

서비스 간 커뮤니케이션을 관리하는 다른 시스템들과 달리, **서비스 메쉬는 애플리케이션에 구축된 전용 인프라 계층**이다.

이 가시적인 인프라 계층은 __서로 다른 애플리케이션 부분이 얼마나 원활하게 상호작용하는지 여부를 기록__할 수 있으므로, 더욱 손쉽게 커뮤니케이션을 최적화하고 애플리케이션 확장에 따른 다운타임을 방지할 수 있다.

현대적인 애플리케이션은 각각 특정한 비즈니스 기능을 수행하는 서비스 네트워크로 분류된다.
기능을 실행하기 위해 서비스는 여러 개의 다른 서비스들로부터 데이터를 요청해야 할 수 있다.
하지만 이 때 일부 서비스에 요청이 과도하게 몰릴 경우가 있다. 
이 때, 한 서비스에서 다음 서비스로 요청을 전송하여 모든 구성 요소의 작동 방식을 최적화하는 서비스 메쉬를 도입한다.



## 작동방법

서비스 메쉬에서는 요청이 자체 인프라 계층의 프록시를 통해 마이크로서비스 간에 라우팅된다.

이러한 이유로 **서비스 메쉬를 구성하는 개별 프록시는 서비스 내부가 아니라 각 서비스와 함께 실행되므로 "Sidecar" **라고 한다. 각 서비스에서 분리된 이러한 **sidecar 프록시들이 모여 메쉬 네트워크를 형성**한다.

> 사이드카 패턴이란?
>
> 기본 애플리케이션 외 필요한 추가 기능을 별도의 애플리케이션으로 구현하고 이를 동일한 프로세스 또는 컨테이너 내부에 배치하는 것
>
> 동일한 프로세스 또는 컨테이너에 배치된 사이드카 애플리케이션은 저장 공간, 네트워크 등의 리소스를 공유하며 모니터링, 로깅, 프록시 등의 동작을 한다.

— sidecar 의 장점

	1. 기본 애플리케이션의 로직을 수정하지 않고도 추가 기능을 수행할 수 있다.
 	2. 사이드카 애플리케이션은 기본 애플리케이션과 리소스를 공유할 수 있다.
     이를 통해 모니터링에 필요한 Metrics 수집, 프록시 동작 등을 수행할 수 있다.

![service-mesh](/Users/hanjoo/github_blog/assets/image/Kiali/service-mesh.png)

서비스 간 통신은 사이드카로 배치된 Proxy를 통해서 동작한다. 
이 Proxy에 Routing rules, retry, timeout 등을 설정하고 로직을 작성하여 공통 기능을 기본 애플리케이션에서 분리시킬 수 있다.



## 네트워크 토폴로지

**topology는 컴퓨터 네트워크의 요소들을 물리적으로 연결해 놓은 것, 또는 그 연결 방식을 말한다.**



___

참고

<https://www.redhat.com/ko/topics/microservices/what-is-a-service-mesh>

[https://medium.com/dtevangelist/service-mesh-%EB%9E%80-8dfafb56fc07](https://medium.com/dtevangelist/service-mesh-란-8dfafb56fc07)

[https://ko.wikipedia.org/wiki/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC_%ED%86%A0%ED%8F%B4%EB%A1%9C%EC%A7%80](https://ko.wikipedia.org/wiki/네트워크_토폴로지)