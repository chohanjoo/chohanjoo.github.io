---
layout: post
title:  "쿠버네티스 용어 정리 - 조대협 블로그"
date:   2019-05-09 18:40:59
tags:    [Cloud, Container, K8s]
comments: true
---
# 쿠버네티스 용어 정리 

## 아래의 글은 조대협님의 '쿠버네티스 #2 - 개념 이해(1/2)' 를 가져온 글이다.

<https://bcho.tistory.com/1256?category=731548>



쿠버네티스의 개념은 크게 오브젝트 두개의 개념에서 출발

## 마스터와 노드

쿠버네티스를 이해하기 위해서는 클러스터의 구조를 이해해야 한ㄷ마.

클러스터 전체를 관리하는 컨트롤로써 마스터가 존재하고, 컨테이너가 배포되는 머신인 노드가 존재한다.

![k8s_master_node](/Users/hanjoo/github_blog/assets/image/k8s_master_node.png)



## 오브젝트

쿠버네티스를 이해하기 위해 가장 중요한 부분이 오브젝트이다.

기본적인 구성단위가 되는 기본 오브젝트 ( Basic object )와, 이 기본 오브젝트를 생성하고 관리하는 추가적인 기능을 가진 컨트롤러(Controller)로 이루어진다. 그리고 이러한 오브젝트의 스펙(설정) 이외에 추가정보인 메타 정보들로 구성이 된다고 보면 된다.



## 오브젝트 스펙 ( Object Spec )

오브젝트들은 모두 오브젝트의 특성 (설정정보)를 기술한 오브젝트 스펙으로 정의가 되고, 커맨드 라인을 통해 오브젝트 생성시 인자로 전달하여 정의 하거나 또는 yaml이나 json 파일로 스펙을 정의할 수 있다.



## 기본 오브젝트 ( Basic Object )

쿠버네티스에 의해서 배포 및 관리되는 가장 기본적인 오브젝트는 컨테이너화되어 배포되는 애플리케이션의 워크로드를 기술하는 오브젝트로 Pod, Service, Volume, Namespace 4가지가 있다.

Pod = 컨테이너화된 애플리케이션
Volume = 디스크
Service = 로드밸런서
Namespace  = 패키지명

### Pod

쿠버네티스에서 가장 기본적인 배포 단위로, **컨테이너를 포함하는 단위**

쿠버네티스의 특징중의 하나는 컨테이너를 개별적으로 하나씩 배포하는 것이 아니라 Pod 라는 단위로 배포하는데, Pod는 하나 이상의 컨테이너를 포함한다.

~~~
apiVersion : v1
kind : Pod
metadata : 
	name : nginx
spec:
	containers:
		-name : nginx
		image : nginx:1.7.9
		ports:
		- containerPort : 8080
~~~

- apiVersion : 이 스크립트를 실행하기 위한 쿠버네티스 API 버전
- kind : 리소스의 종류를 정의
- metadata : 라벨이나 리소스의 이름 등 각종 메타데이터를 넣는다.
- spec : 리소스에 대한 상세한 스펙을 정의

Pod는 다음과 같은 특징을 갖는다.

1. Pod 내의 컨테이너는 IP와 Port를 공유한다.

   두 개의 컨테이너가 하나의 Pod을 통해서 배포되었을 때, localhost를 통해서 통신이 가능하다..

2. Pod 내에 배포된 컨테이너 간에는 디스크 볼륨을 공유할 수 있다.

   쿠버네티스의 경우 하나의 Pod 내에서는 컨테이너끼리 볼륨을 공유할 수 있기 때문에 다른 컨테이너의 파일을 읽을 수 있음

   ![k8s_pod](/Users/hanjoo/github_blog/assets/image/k8s_pod.png)



### Volume

Pod가 기동할 때 디폴트로, 컨테이너마다 로컬 디스크를 생성해서 기동되는데, 이 로컬 디스크의 경우에는 영구적이지 못하다. 즉, 컨테이너가 restart 되거나, 새로 배포될 때 마다 로컬 디스크는 Pod 설정에 따라서 새롭게 정의되서 배포되기 때문에, 디스크에 기록된 내용이 유실된다.

DB와 같이 영구적으로 파일을 저장해야 하는 경우에는 컨테이너 restart에 상관 없이 파일을 영속적으로 저장해야 하는데, 이러한 형태의 스토리지를 볼륨이라고 한다.

볼륨은 컨테이너의 외장 디스크로 생각하면 된다. Pod가 기동할 때 컨테이너에 마운트해서 사용한다.

쿠버네티스의 볼륨은 컨테이너간의 공유기 가능하다.



### Service

Pod와 볼륨을 이용하여, 컨테이너들을 정의한 후에, Pod를 서비스 제공할 때, 일반적인 분산환경에서 하나의 Pod로 서비 하는 경우는 드물고, 여러개의 Pod를 서비스하면서, 이를 로드밸런서를 이용하여 하나의 IP와 포트로 묶어서 서비스를 제공한다.

Pod의 경우에는 동적으로 생성이 되고, 장애가 생기면 자동으로 restart 되면서 그 IP가 바뀌기 때문에, 로드밸런스에서 Pod의 목록을 지정할 때는 IP주소를 이용하는 것은 어렵다. 또한 오토 스케일링으로 인하여 Pod가 동적으로 추가 또는 삭제되기 때문에, 이렇게 추가/삭제된 Pod 목록을 로드밸런스가 유연하게 선택해 줘야 한다.

그래서 사용하는 것이 라벨( label )과 라벨 셀렉터( label selector ) 라는 개념이다.

라벨 셀렉터 : 서비스를 정의할 때, 어떤 Pod를 서비스로 묶을 것인지 정의하는 것

각 Pod를 생성할 때 메타데이터 정보 부분에 라벨을 정의할 수 있다.

서비스는 라벨 셀렉터에서 특정 라벨을 가지고 있는 Pod만 선택하여 서비스에 묶게 된다.

![k8s_service](/Users/hanjoo/github_blog/assets/image/k8s_service.png)

해당 그림은 서비스가 라벨이 'myapp' 인 서비스만 골라내서 서비스에 넣고, 그 Pod간에만 로드밸런싱을 통하여 외부로 서비스를 제공하는 형태이다.

이를 스펙으로 정의해보면 다음과 같다.

~~~
kind : Service
apiVersion : v1
metadata :
	name : my-service
spec : 
	selector : 
		app : myapp
	ports :
	- protocol : TCP
	port : 80
	targetPort : 9378
~~~



- 리소스 종류가 Service 이기 때문에, kind는 Service로 지정
- 스크립트를 실행할 api 버전은 v1으로 apiVersion에 정의
- 메타데이터에 서비스의 이름을 my-service로 지정
- selector에서 라벨이 app:myapp 인 Pod만을 선택해서 서비스에서 서비스를 제공하게 하고
- 포트는 TCP를 이용하되, 서비스는 80포트로 서비스를 하되, 서비스의 80포트의 요청을 컨테이너의 9378포트로 연결해서 서비스를 제공



### Name space

네임스페이스는 한 쿠버네티스 클러스터 내의 논리적인 분리단위라고 보면 된다.

Pod, Service 등은 네임 스페이스 별로 생성이나 관리가 될 수 있고, 사용자의 권한 역시 이 네임 스페이스 별로 나눠서 부여할 수 있다.

즉, 하나의 클러스터 내에, 개발/운영/테스트 환경이 있을 때, 클러스터를 개발/운영/테스트 3개의 네임 스페이스로 나눠서 운영할 수 있다.

Name space로 할 수 있다?

​	-> 사영자별로 Name space별 접근 권한을 다르게 운영할 수 있다.

​	-> 네임스페이스별로 리소스의 쿼타 (할당량)을 지정할 수 있다. 개발계에는 CPU 100, 운영계에는 CPU 400과 GPU 100 개 식으로, 		사용 가능한 리소스의 수를 지정할 수 있다.

​	-> 네임 스페이스 별로 리소스를 나눠서 관리 할 수 있다. (Pod, Service 등)



** 주의할 점은 네임 스페이스는 논리적인 분리 단위이지 물리적이나 기타 장치를 통해서 분리한 것이 아니다. 다른 네임 스페이스간의 pod라도 통신은 가능하다.



## 라벨

라벨은 쿠버네티스의 리소스를 선택하는데 사용이 된다.

각 리소스는 라벨을 가질 수 있고, 라벨 검색 조건에 따라서 특정 라벨을 가지고 있는 리소스만을 선택 할 수 있다.

이렇게 라벨을 선택하여 특정 리소스만 배포하거나 업데이트 할 수 있고 또는 라벨로 선택된 리소스만 Service에 연결하거나 특정 라벨로 선택된 리소스엠나 네트워크 접근 권한을 부여하는 등의 행위를 할 수 있다.

라벨은 metadata 섹션에 키/값 쌍을 정의가 가능하며, 하나의 리소스에는 하나의 라벨이 아니라 여러 라벨을 동시에 적용 할 수 있다.

~~~
"metadata" : {
	"labels" : {
		"key1" : "value1",
		"key2" : "value2"
	}
}
~~~

셀렉터를 사용하는 방법은 오브젝트 스펙에서 selector라고 정의하고 라벨 조건을 적어 놓으면 된다.

쿠버네티스에서는 두 가지 셀렉터를 제공하는데, 기본적으로  Equaility based selector. Set based selector가 있다.

Equality based selector = 같냐, 다르냐와 같은 조건을 이용하여 리소스를 선택하는 방법

​	-> environment = dev

​	-> tier != frontend

Set based selector = 집합의 개념을 사용

​	-> environment in (production, qa) 는 environment가 production 또는 qa인 경우이다.

​	-> tier notin (frontend, backend)는 environment가 frontend도 아니고 backend도 아닌 리소스를 선택하는 방법

다음 예제는 my-service라는 이름의 서비스를 정의한 것으로 셀렉터에서 app:myapp 정의해서 Pod의 라벨 app이 myapp 인 것만 골라서 이 서비스에 바인딩해서 9376 포트로 서비스 하는 예제이다.

~~~
kind: Service
apiVersion : v1
metadata:
	name: my-service
spec:
	selector:
		app: myapp
	ports:
	- protocol: TCP
		port: 80
		targetPort: 9376
~~~



## 컨트롤러

앞에서 소개한 4개의 기본 오브젝트로, 애플리케이션을 설정하고 배포하는 것이 가능한데 이를 조금 더 편리하게 관리하기 위해서 쿠버네티스는 컨트롤러라는 개념을 사용한다.

컨트롤러는 기본 오브젝트들을 생성하고 이를 관리하는 역할을 한다.

컨트롤러는 Replication Controller (aka RC), Replication Set, Daemon Set, Job, StatefulSet, Deployment 가 있다.



### Replication Controller

Pod를 관리해주는 역할을 하며, 지정된 숫자로 Pod를 기동 시키고, 관리하는 역할을 한다.

Replication Controller (이하 RC)는 크게 3가지 파트로 구성되는데, Replica의 수, Pod Selector, Pod Template 3가지로 구성된다.

- Selector : 먼저 Pod selector는 라벨을 기반으로 하여,  RC가 관리한 Pod를 가지고 오는데 사용한다.

- Replica 수 :  RC에 의해서 관리하는 Pod의 수인데, 그 숫자만큼 Pod의 수를 유지하도록 한다.

  예를 들어  replica 수가 3이면, 3개의 Pod만 띄우도록 하고, 이보다 Pod가 모자르면 새로운 Pod를 띄우고, 이보다 숫자가 많으면 남는 Pod를 삭제한다.

- Pod를 추가로 기동할 때 그러면 어떻게 Pod를 만들지 Pod에 대한 정보 (도커 이미지, 포트. 라벨 등)에 대한 정보가 필요한데, 이는  Pod template이라는 부분에 정의 한다.

![k8s_rc](/Users/hanjoo/github_blog/assets/image/k8s_rc.png)

**이미 돌고 있는 Pod가 있는 상태에서  RC 리소스를 생성하면 그 Pod의 라벨이 RC의 라벨과 일치하면 새롭게 생성된 RC의 컨트롤을 받는다. 만약 해당 Pod들이 RC에서 정의한 replica 수 보다 많으면, replica 수에 맞게 추가분의 pod를 삭제하고, 모자르면 template에 정의된 pod 정보에 따라서 새로운 Pod를 생성하는데, 기존에 생성되어 있는 Pod가 template에 정의된 스펙과 다를지라도 그 Pod를 삭제하지 않는다.

~~~
apiVersion : v1
kind: ReplicationController
metadata:
	name: ngninx
spec:
	replicas: 3
	selector:
		app: nginx
	template:
		metadata:
			name: nginx
			labels:
				app: nginx
			spec:
				containers:
				- name: nginx
					image: nginx
					ports:
					- containerPort : 80
~~~

이 예제는 nginx라는 이름의 RC를 정의한 것으로, label이 "app:nginx"인 Pod들을 관리하고 3개의 Pod가 항상 운영되도록 설정한다.
Pod는  app:nginx 라는 라벨을 가지면서 이름이 nginx이고 nginx 이미지를 사용해서 생성하고 컨테이너의 포트는 80번 포트를 이용해서 서비스를 제공한다.

### ReplicaSet

ReplicaSet은 Replication Controller의 새버전으로 생각하면 된다.

Replication Controller 는 Equality based Selector를 이용하는데 반해,

ReplicaSet은 Set based Selector를 이용한 것이다.



## Deployment

Deployment는 Replication Controller와 Replica Set의 상위 추상화 개념이다. 

실제 운영에서는 ReplicaSet, Replication Controller를 바로 사용하는 것보다, 추상화된 Deployment를 사용하게 된다.

------

출처

<https://bcho.tistory.com/1256?category=731548>
