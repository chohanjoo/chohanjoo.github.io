---
layout: post
title:  "kubectl을 사용해서 디플로이먼트 생성하기"
author: Joo
noindex: true
---
# kubectl을 사용해서 디플로이먼트 생성하기



## 쿠버네티스 디플로이먼트

일단 쿠버네티스 클러스터를 구동시키면, 그 위에 컨테이너화된 애플리케이션을 배포할  수 있다.
그러기 위해서, 쿠버네티스 디플로이먼트 설정을 만들어야 한다.

**디플로이먼트는 쿠버네티스가 애플리케이션의 인스턴스를 어떻게 생성하고 업데이트해야 하는지를 지시한다.**

디폴로이먼트가 만들어지면, 쿠버네티스 마스터가 해당 애플리케이션 인스턴스를 클러스터의 개별 노드에 스케줄한다.

애플리케이션 인스턴스가 생성되면, 쿠버네티스 디플로이먼트 컨트롤러는 지속적으로 이들 인스턴스를 모니터링한다.

인스턴스를 구동 중인 노드가 다운되거나 삭제되면, 디플로이먼트 컨트롤러가 인스턴스를 클러스터 내부의 다른 노드의 인스턴스로 교체시켜준다.

**이렇게 머신의 장애나 정비에 대응할 수 있는 자동 복구(self-healin) 메커니즘을 제공한다.**



![module_02_first_app](/assets/image/module_02_first_app.svg)



Kubectl 이라는 쿠버네티스 CLI를 통해 디플로이먼트를 생성하고 관리 할 수 있다.

Kubectl은 클러스터와 상호 작용하기 위해 쿠버네티스 API를 사용한다.

해당 포스트에서는, 쿠버네티스 클러스터 상에 애플리케이션을 구동시키는 디플로이먼트를 생성하기 위해 필요한 가장 일반적인 Kubectl 명령어를 배운다.

디로이먼트를 생성할 때, 애플리케이션에 대한 컨테이너 이미지와 구동시키고자 하는 복제 수를 지정해야 한다.



여기서는 첫 번째 디플로이먼트로, Docker 컨테이너로 패키지된 Node.js 애플리케이션을 사용한다.



### Kubectl 버전 확인

~~~
kubectl version
~~~



### 클러스터 안에 있는 노드 확인

~~~
kubectl get nodes
~~~

![k8s_kubectl_getnode](/assets/image/k8s_kubectl_getnode.png)



## 쿠버네티스에 있는 첫번째 앱 실행

'run' 명령어는 새로운 디플로이먼트를 만든다. 이 때 배포할 이름과 앱 이미지 위치를 제공해야 한다. 또한 특정 포트에서 앱을 실행하려면 --port 를 추가해야 한다.

~~~
kubectl run kubernetes-bootcamp --image=gcr.io/google-samples-kubernetes-bootcamp:v1 --port=8080
~~~

이 명령어는 다음과 같은 일을 수행한다.

1. 애플리케이션의 인스턴스가 실행될 수 있는 적합한 노드를 찾는다.
2. 해당 노드에서 실행할 애플리케이션 예약
3. 필요할 때 새 노드에서 인스턴스 예약하도록 클러스터 구성

### 디폴로이먼트 리스트 확인

~~~
kubectl get deployments
~~~

![k8s_kubectl_getdeployment](/assets/image/k8s_kubectl_getdeployment.png)

앱의 단일 인스턴스를 실행하는 1개의 디플로이먼트를 볼 수 있다. 인스턴스가 노드의 Docker 컨테이너 안에서 실행되고 있다.



## 앱 보기

쿠버네티스 내부에서 실행되고 있는 파드는 전용의 고립된 네트워크에서 실행된다. 
기본적으로 파드은 동일한 쿠버네티스 클러스터 내의 다른 파드 및 서비스에서 볼 수 있지만, 그 네트워크 외부에서는 볼 수 없다.  kubectl을 사용할 때, 애플리케이션과 통신하기 위해 API endpoint를 통해 커뮤니케이션 한다.

kubectl 명령어는 클러스터의 private 네트워크와 커뮤니케이션 할 수 있는 proxy를 생성할 수 있다.

~~~
kubectl proxy
~~~



이제 호스트(터미널)와 쿠버넷 클러스터 사이에 연결이 되어 있다. proxy는 터미널에서 API에 직접 접속할 수 있게 한다.



이제 http : // localhost : 8001에서 사용할 수있는 proxy endpoint를 통해 호스팅되는 모든 API를 볼 수 있습니다. 
예를 들어 curl 명령을 사용하여 API를 통해 버전을 직접 쿼리 할 수 있습니다.

~~~ 
curl http://localhost:8001/version
~~~

![스크린샷 2019-06-08 오후 9.17.23](/Users/hanjoo/github_blog/assets/image/k8s/스크린샷 2019-06-08 오후 9.17.23.png)API 서버는 자동으로 proxy를 통해 액세스 할 수있는 파드 이름에 따라 각 파드에 대한 end point를 작성합니다.



Pod 이름을 가져와 POD_NAME 환경 변수에 저장합니다.

~~~
export POD_NAME=$(kubectl get pods -o go-template --template '{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}')

~~~



이제 해당 pod에서 실행중인 응용 프로그램에 대한 HTTP 요청을 만들 수 있습니다.